#include "strategy.h"
#include "poi.h"
#include "robot.h"
#include "routines.h"

void match(){
    //start match
    motion.setFeedrate(1.0);

    if(ihm.isColor(Settings::BLUE)) 
        matchA();
    else 
        matchB();

}

void recalage(){
    motion.engage();
    //motion.setSync();
    //actuators.moveElevator(RobotCompass::BC,ElevatorPose::UP);
    waitMs(800);
    //THROW(1)
    motion.setAbsPosition(Vec3(0,0,DEG_TO_RAD *90));
    if(ihm.isColor(Settings::BLUE)){
        probeBorder(TableCompass::SOUTH, RobotCompass::BC,100);
        probeBorder(TableCompass::EAST,  RobotCompass::CA,100);
        async motion.go(POI::b2);
        async motion.align(RobotCompass::BC, getCompassOrientation(TableCompass::SOUTH));
        motion.setAbsPosition(Vec3(POI::b2, motion.getOrientation()));
        //actuators.moveElevator(RobotCompass::AB,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::BC,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::CA,ElevatorPose::GRAB);
    }else{
        //motion.setAbsPosition({-1,-1,PI});
        probeBorder(TableCompass::SOUTH, RobotCompass::BC,100);
        probeBorder(TableCompass::WEST,  RobotCompass::AB,100);

        motion.enableCruiseMode();
        async motion.go(POI::y2);
        motion.disableCruiseMode();
        async motion.align(RobotCompass::BC, getCompassOrientation(TableCompass::SOUTH));
        motion.setAbsPosition(Vec3(POI::y2, motion.getOrientation()));
        //actuators.moveElevator(RobotCompass::AB,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::BC,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::CA,ElevatorPose::GRAB);
    }
    motion.disengage();
}

//BLUE
void matchA(){
    //do Match
    //async motion.turn(3600);
    //motion.enableCruiseMode();
    for(int i = 0; i < 10; i++){
        async motion.go(POI::b2 + Vec2(0,-600));
        async motion.go(POI::b2);
    }

    chrono.onMatchNearlyFinished();
    chrono.onMatchFinished();
}

void matchB(){
    //do Match
    //async motion.turn(-3600);
    /*
    motion.enableCruiseMode();
    for(int i = 0; i < 10; i++){
        async motion.go(POI::y2 + Vec2(0,-600));
        async motion.go(POI::y2);
    }*/

    // Strategy generated by StrategyEditor
    // Total points: 11
    //motion.enableCruiseMode();
    async motion.go(POI::y2);  // Step 1 - POI y2
    async motion.go(POI::BannerYellow);  // Step 2 - POI BannerYellow
    actuators.moveElevator(RobotCompass::BC, ElevatorPose::DOWN);
    async motion.go(POI::y2);  // Step 1 - POI y2
    async motion.align(RobotCompass::AB, getCompassOrientation(TableCompass::NORTH));
    async motion.go(1100, 1300);  // Step 3
    async motion.go(POI::stock_4);  // Step 4 - POI stock_4
    async motion.align(RobotCompass::AB, getCompassOrientation(TableCompass::SOUTH));
    async motion.go(POI::constAreaYellow_2);  // Step 5 - POI constAreaYellow_2
    async motion.go(1218, 1448);  // Step 6
    async motion.align(RobotCompass::AB, getCompassOrientation(TableCompass::SOUTH));
    async motion.go(768, 1455);  // Step 7
    async motion.go(POI::stock_3);  // Step 8 - POI stock_3
    async motion.go(POI::constAreaYellow_1);  // Step 9 - POI constAreaYellow_1
    async motion.go(POI::waitPointYellow);  // Step 10 - POI waitPointYellow
    async motion.go(POI::y1);  // Step 11 - POI y1

    chrono.onMatchNearlyFinished();
    chrono.onMatchFinished();
}


void waitMs(unsigned long time){
    os.wait(time,false);
    //delay(time);
}


RobotCompass nextActuator(RobotCompass rc){
    int RobotCompassSize = 6;
    return static_cast<RobotCompass>((static_cast<int>(rc) + 2) % RobotCompassSize);
}

RobotCompass previousActuator(RobotCompass rc){
    int RobotCompassSize = 6;
    return static_cast<RobotCompass>((static_cast<int>(rc) + RobotCompassSize - 2) % RobotCompassSize);
}

void probeBorder(TableCompass tc, RobotCompass rc, float clearance, float approachDist, float probeDist){
	boolean wasAbsolute = motion.isAbsolute();
    float currentFeedrate = motion.getFeedrate();
    motion.disableCruiseMode();
	bool m_probing = true;
    motion.setFeedrate(0.3);
	async motion.align(rc, getCompassOrientation(tc));

    motion.setRelative();
	async motion.goPolar(getCompassOrientation(rc),approachDist);
	async motion.goPolar(getCompassOrientation(rc),probeDist);

	float _offset = getOffsets(rc);

	Vec3 position = motion.getAbsPosition();

	if(tc == TableCompass::NORTH){
		position.y = 0.0 + _offset; //We hit Xmax
		//_probedX = true;
	}else if(tc == TableCompass::SOUTH){
		position.y = 2000.0 - _offset; //We hit Xmin
		//_probedX = true;
	}else if(tc == TableCompass::EAST){
		position.x = 3000.0 - _offset; //We hit Ymax
		//_probedY = true;
	}else if(tc == TableCompass::WEST){
		position.x = 0.0 + _offset; //We hit Ymin
		//_probedY = true;
	}
    position.c = DEG_TO_RAD * (getCompassOrientation(tc) - getCompassOrientation(rc));
	Console::println(position.c * RAD_TO_DEG);
    motion.setAbsPosition(position);

	async motion.goPolar(getCompassOrientation(rc),-clearance);
	if(wasAbsolute) motion.setAbsolute();
    motion.setFeedrate(currentFeedrate);

}
