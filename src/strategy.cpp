#include "strategy.h"
#include "poi.h"
#include "robot.h"
#include "routines.h"

void match(){
    //start match
    motion.setFeedrate(1.0);

    if(ihm.isColor(Settings::BLUE)) 
        matchA();
    else 
        matchB();

}

void recalage(){
    motion.engage();
    //motion.setSync();
    //actuators.moveElevator(RobotCompass::BC,ElevatorPose::UP);
    waitMs(800);
    //THROW(1)
    motion.setAbsPosition(Vec3(0,0,DEG_TO_RAD *90));
    if(ihm.isColor(Settings::BLUE)){
        probeBorder(TableCompass::SOUTH, RobotCompass::BC,100);
        probeBorder(TableCompass::EAST,  RobotCompass::CA,100);
        async motion.go(POI::b2);
        async motion.align(RobotCompass::BC, getCompassOrientation(TableCompass::SOUTH));
        motion.setAbsPosition(Vec3(POI::b2, motion.getOrientation()));
        //actuators.moveElevator(RobotCompass::AB,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::BC,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::CA,ElevatorPose::GRAB);
    }else{
        //motion.setAbsPosition({-1,-1,PI});
        probeBorder(TableCompass::SOUTH, RobotCompass::BC,100);
        probeBorder(TableCompass::WEST,  RobotCompass::AB,100);

        motion.enableCruiseMode();
        async motion.go(POI::y2);
        motion.disableCruiseMode();
        async motion.align(RobotCompass::BC, getCompassOrientation(TableCompass::SOUTH));
        motion.setAbsPosition(Vec3(POI::y2, motion.getOrientation()));
        //actuators.moveElevator(RobotCompass::AB,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::BC,ElevatorPose::GRAB);
        //actuators.moveElevator(RobotCompass::CA,ElevatorPose::GRAB);
    }
    motion.disengage();
}

//BLUE
void matchA(){
    //do Match
    //async motion.turn(3600);
    //motion.enableCruiseMode();
    for(int i = 0; i < 10; i++){
        async motion.go(POI::b2 + Vec2(0,-600));
        async motion.go(POI::b2);
    }

    chrono.onMatchNearlyFinished();
    chrono.onMatchFinished();
}

void matchB(){
    //do Match
    //async motion.turn(-3600);
    /*
    motion.enableCruiseMode();
    for(int i = 0; i < 10; i++){
        async motion.go(POI::y2 + Vec2(0,-600));
        async motion.go(POI::y2);
    }*/

    // Strategy generated by StrategyEditor
    // Total points: 11
    //motion.enableCruiseMode();
    async motion.go(POI::y2);  // Step 1 - POI y2
    async motion.go(POI::BannerYellow);  // Step 2 - POI BannerYellow
    async motion.go(POI::BannerYellow + Vec2(0,50));  // Step 2 - POI BannerYellow
    //probeBorder(TableCompass::SOUTH, RobotCompass::BC, 100);
    actuators.moveElevator(RobotCompass::BC, ElevatorPose::DOWN);
    async motion.go(POI::y2);  // Step 1 - POI y2

    takeStock(POI::stock_4, RobotCompass::AB, TableCompass::NORTH);// Step 4 - POI stock_4

    async motion.align(RobotCompass::AB, getCompassOrientation(TableCompass::SOUTH));
    async motion.go(POI::constAreaYellow_2);  // Step 5 - POI constAreaYellow_2
    async motion.go(1218, 1448);  // Step 6
    async motion.align(RobotCompass::AB, getCompassOrientation(TableCompass::SOUTH));
    async motion.go(768, 1455);  // Step 7
    async motion.go(POI::stock_3);  // Step 8 - POI stock_3
    async motion.go(POI::constAreaYellow_1);  // Step 9 - POI constAreaYellow_1
    async motion.go(POI::waitPointYellow);  // Step 10 - POI waitPointYellow
    async motion.go(POI::y1);  // Step 11 - POI y1

    chrono.onMatchNearlyFinished();
    chrono.onMatchFinished();
}


void waitMs(unsigned long time){
    os.wait(time,false);
    //delay(time);
}



void takeStock(Vec2 target, RobotCompass rc, TableCompass tc){
    if(rc == RobotCompass::BC){
        THROW("wrong compass");
        return;
    }

    RobotCompass nextCompass = (rc == RobotCompass::AB) ? RobotCompass::CA : RobotCompass::AB;

    float approachOffset = 250;
    float grabOffset = 175;
    float canOffset = 100;
    float canGrab = 100;

    Vec2 approach = target - PolarVec(getCompassOrientation(tc)*DEG_TO_RAD, approachOffset).toVec2();
    Vec2 grab = target - PolarVec(getCompassOrientation(tc)*DEG_TO_RAD, grabOffset).toVec2();

    // ---- Take first planks ----
    async motion.go(approach); 
    async motion.align(rc, getCompassOrientation(tc));
    
    actuators.moveElevator(rc, ElevatorPose::UP);
    actuators.grabPlank(rc);
    waitMs(800);
    async motion.go(grab);
    waitMs(800);

    actuators.moveElevatorOffset(rc, ElevatorPose::DOWN, -20);
    waitMs(800);
    actuators.storePlank(rc);



    // ---- Take second planks ----
    async motion.go(approach); 
    async motion.align(nextCompass, getCompassOrientation(tc));

    actuators.moveElevator(nextCompass, ElevatorPose::UP);
    actuators.grabPlank(nextCompass);
    waitMs(800);
    async motion.go(grab);
    waitMs(800);

    actuators.moveElevatorOffset(nextCompass, ElevatorPose::DOWN, -20);
    waitMs(800);
    actuators.storePlank(nextCompass);


    // ---- Take second can ----
    async motion.goPolar(getCompassOrientation(tc)+90, canOffset); 
    actuators.grab(nextCompass);
    async motion.goPolar(getCompassOrientation(tc), canGrab);
    async motion.goPolar(getCompassOrientation(tc), -canGrab);

    // ---- take first can ---- 
    async motion.align(rc, getCompassOrientation(tc));
    async motion.goPolar(getCompassOrientation(tc)-90, canOffset*2);
    actuators.grab(rc);
    async motion.goPolar(getCompassOrientation(tc), canGrab);
    async motion.goPolar(getCompassOrientation(tc), -canGrab);

    motion.setFeedrate(1.0);
}
/*
void takeStock(Vec2 target, RobotCompass rc, TableCompass tc){
    float startOffset = 260.0;
    float grabOffset = 80.0;
    float pushOffset = 70.0;
    float newTargetY = target.y;

    // Ralentir
    motion.setFeedrate(0.7);

    // Mettre les bras en position Grab
    actuators.moveElevator(RobotCompass::AB,ElevatorPose::DOWN);
    actuators.moveElevator(RobotCompass::BC,ElevatorPose::DOWN);
    actuators.moveElevator(RobotCompass::CA,ElevatorPose::DOWN);

    // On se positionne en bordure de zone
    if(tc == TableCompass::EAST) newTargetY = newTargetY - startOffset;
    else if(tc == TableCompass::WEST) newTargetY = newTargetY + startOffset;
    async motion.go(target.x, newTargetY);

    for(int i = 0; i < 3; i++){
        actuators.drop(rc);

        // Avancer vers la plante seulement si pas la premiere fois
        if(i > 0){
            if(tc == TableCompass::EAST) newTargetY = newTargetY + grabOffset;
            else if(tc == TableCompass::WEST) newTargetY = newTargetY - grabOffset;
            async motion.go(target.x, newTargetY);
        }
        // Rapprocher les plantes
        actuators.grab(rc);
        waitMs(500);

        // Avancer un peu avant de grab
        if(tc == TableCompass::EAST) async motion.go(target.x, newTargetY + pushOffset);
        else if(tc == TableCompass::WEST) async motion.go(target.x, newTargetY - pushOffset);

        // Prendre les plantes
        actuators.grab(rc);
        waitMs(500);

        // Reculer
        if(tc == TableCompass::EAST) async motion.go(target.x, newTargetY);
        else if(tc == TableCompass::WEST) async motion.go(target.x, newTargetY);

        // Lever les plantes et suivant
        actuators.moveElevator(rc,ElevatorPose::UP);
        rc = nextActuator(rc);
        if(i<2) async motion.align(rc, getCompassOrientation(tc)); // Ne pas effectuer la rotation sur la derniere action
    }

    motion.setFeedrate(1.0);
}
*/

RobotCompass nextActuator(RobotCompass rc){
    int RobotCompassSize = 6;
    return static_cast<RobotCompass>((static_cast<int>(rc) + 2) % RobotCompassSize);
}

RobotCompass previousActuator(RobotCompass rc){
    int RobotCompassSize = 6;
    return static_cast<RobotCompass>((static_cast<int>(rc) + RobotCompassSize - 2) % RobotCompassSize);
}

void probeBorder(TableCompass tc, RobotCompass rc, float clearance, float approachDist, float probeDist){
	boolean wasAbsolute = motion.isAbsolute();
    float currentFeedrate = motion.getFeedrate();
    motion.disableCruiseMode();
	bool m_probing = true;
    motion.setFeedrate(0.3);
	async motion.align(rc, getCompassOrientation(tc));

    motion.setRelative();
	async motion.goPolar(getCompassOrientation(rc),approachDist);
	async motion.goPolar(getCompassOrientation(rc),probeDist);

	float _offset = getOffsets(rc);

	Vec3 position = motion.getAbsPosition();

	if(tc == TableCompass::NORTH){
		position.y = 0.0 + _offset; //We hit Xmax
		//_probedX = true;
	}else if(tc == TableCompass::SOUTH){
		position.y = 2000.0 - _offset; //We hit Xmin
		//_probedX = true;
	}else if(tc == TableCompass::EAST){
		position.x = 3000.0 - _offset; //We hit Ymax
		//_probedY = true;
	}else if(tc == TableCompass::WEST){
		position.x = 0.0 + _offset; //We hit Ymin
		//_probedY = true;
	}
    position.c = DEG_TO_RAD * (getCompassOrientation(tc) - getCompassOrientation(rc));
	Console::println(position.c * RAD_TO_DEG);
    motion.setAbsPosition(position);

	async motion.goPolar(getCompassOrientation(rc),-clearance);
	if(wasAbsolute) motion.setAbsolute();
    motion.setFeedrate(currentFeedrate);

}
