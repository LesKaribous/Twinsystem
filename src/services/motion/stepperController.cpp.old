#include "stepperController.h"

#include <algorithm>
#include <cmath>
#include <cstdlib>

// Constructor.
StepperController::StepperController() : 
    m_sA(Pin::Stepper::stepA, Pin::Stepper::dirA, !Settings::Stepper::DIR_A_POLARITY),
    m_sB(Pin::Stepper::stepB, Pin::Stepper::dirB, !Settings::Stepper::DIR_B_POLARITY),
    m_sC(Pin::Stepper::stepC, Pin::Stepper::dirC, !Settings::Stepper::DIR_C_POLARITY),
    targetA(0), targetB(0), targetC(0),
    m_startA(0), m_startB(0), m_startC(0),
    m_totalDistanceA(0), m_totalDistanceB(0), m_totalDistanceC(0),
    m_totalTime(0), m_startTime(0)
{
    // Initialization of steppers acceleration parameters.
    m_sA.setAcceleration(Settings::Stepper::MAX_ACCEL);
    m_sB.setAcceleration(Settings::Stepper::MAX_ACCEL);
    m_sC.setAcceleration(Settings::Stepper::MAX_ACCEL);
    
    m_sA.setDeceleration(Settings::Stepper::STOP_DECCEL);
    m_sB.setDeceleration(Settings::Stepper::STOP_DECCEL);
    m_sC.setDeceleration(Settings::Stepper::STOP_DECCEL);
}
    
// Sets the target positions and computes the move parameters.
void StepperController::setTarget(long posA, long posB, long posC) {
    targetA = posA;
    targetB = posB;
    targetC = posC;
    
    // Record the current positions as the starting positions.
    m_startA = m_sA.getPosition();
    m_startB = m_sB.getPosition();
    m_startC = m_sC.getPosition();
    
    // Compute absolute distances for each axis.
    m_totalDistanceA = std::abs(targetA - m_startA);
    m_totalDistanceB = std::abs(targetB - m_startB);
    m_totalDistanceC = std::abs(targetC - m_startC);
    
    // Use the longest distance to compute the overall move time.
    long maxDistance = std::max({m_totalDistanceA, m_totalDistanceB, m_totalDistanceC});
    m_totalTime = computeMoveTime(maxDistance);
    
    // Record the starting time (in seconds).
    m_startTime = micros() * 1e-6;
    
    Console::info() << "total time:" << m_totalTime << Console::endl;

    // Clear any previous state.
    Job::reset();
}
    
// start() – Enable steppers, then begin the move.
void StepperController::start() {
    Job::start();
    m_sA.enable();
    m_sB.enable();
    m_sC.enable();
    m_startTime = micros() * 1e-6;
}

// run() is called periodically (every STEPPER_COMPUTE_DELAY µs) to update the trajectory.
// It computes the elapsed time and calculates desired instantaneous velocity based on a
// synchronized profile. When paused, it checks for complete stop to recompute parameters.
void StepperController::run() {
    double currentTime = micros() * 1e-6;
    double t = currentTime - m_startTime;
    const int POSITION_THRESHOLD = 2;    // Acceptable error in steps
    const double updateInterval = 0.05;    // Update profile every 50ms

    if (isRunning()) {
        // Only update the profile at discrete control points.

            // --- Update each motor's desired velocity using the synchronous profile ---
            // Motor A:
            long deltaA = targetA - m_startA;
            double signA = (deltaA >= 0) ? 1.0 : -1.0;
            double v_desA = computeProfileVelocity(m_totalDistanceA, t, m_totalTime);
            double a_effA = computeEffectiveAcceleration(m_totalDistanceA, m_totalTime);
            m_sA.setAcceleration(a_effA);
            m_sA.setDeceleration(a_effA);
            m_sA.setTargetVelocity(signA * static_cast<float>(v_desA));

            // Motor B:
            long deltaB = targetB - m_startB;
            double signB = (deltaB >= 0) ? 1.0 : -1.0;
            double v_desB = computeProfileVelocity(m_totalDistanceB, t, m_totalTime);
            double a_effB = computeEffectiveAcceleration(m_totalDistanceB, m_totalTime);
            m_sB.setAcceleration(a_effB);
            m_sB.setDeceleration(a_effB);
            m_sB.setTargetVelocity(signB * static_cast<float>(v_desB));

            // Motor C:
            long deltaC = targetC - m_startC;
            double signC = (deltaC >= 0) ? 1.0 : -1.0;
            double v_desC = computeProfileVelocity(m_totalDistanceC, t, m_totalTime);
            double a_effC = computeEffectiveAcceleration(m_totalDistanceC, m_totalTime);
            m_sC.setAcceleration(a_effC);
            m_sC.setDeceleration(a_effC);
            m_sC.setTargetVelocity(signC * static_cast<float>(v_desC));


        // Check if the current segment should be closed.
        if ((currentTime - m_startTime) >= m_totalTime) {
            long remA = std::abs(targetA - m_sA.getPosition());
            long remB = std::abs(targetB - m_sB.getPosition());
            long remC = std::abs(targetC - m_sC.getPosition());

            if (remA < POSITION_THRESHOLD &&
                remB < POSITION_THRESHOLD &&
                remC < POSITION_THRESHOLD)
            {
                // All motors have reached (or are very near) their target:
                complete();
            }
            else {
                // Not finished: update the starting positions to the actual positions,
                // recalc the remaining distances and segment time.
                m_startA = m_sA.getPosition();
                m_startB = m_sB.getPosition();
                m_startC = m_sC.getPosition();

                m_totalDistanceA = std::abs(targetA - m_startA);
                m_totalDistanceB = std::abs(targetB - m_startB);
                m_totalDistanceC = std::abs(targetC - m_startC);

                long maxDistance = std::max({ m_totalDistanceA, m_totalDistanceB, m_totalDistanceC });
                m_totalTime = computeMoveTime(maxDistance);
                m_startTime = currentTime;
            }
        }
    }
    else if (isPaused()) {
        // During pause, check until the steppers have nearly stopped, then reinitialize.
        if (std::abs(m_sA.getVelocity()) < 10 &&
            std::abs(m_sB.getVelocity()) < 10 &&
            std::abs(m_sC.getVelocity()) < 10)
        {
            m_startA = m_sA.getPosition();
            m_startB = m_sB.getPosition();
            m_startC = m_sC.getPosition();

            m_totalDistanceA = std::abs(targetA - m_startA);
            m_totalDistanceB = std::abs(targetB - m_startB);
            m_totalDistanceC = std::abs(targetC - m_startC);

            long maxDistance = std::max({ m_totalDistanceA, m_totalDistanceB, m_totalDistanceC });
            m_totalTime = computeMoveTime(maxDistance);
            m_startTime = currentTime;
        }
    }
    else if (isCancelled()) {
        if (std::abs(m_sA.getVelocity()) < 10 &&
            std::abs(m_sB.getVelocity()) < 10 &&
            std::abs(m_sC.getVelocity()) < 10) {
            complete();
        }
    }
}


// control() is called at a higher frequency (every STEPPER_DELAY µs)
// and simply delegates to each stepper's control() method.
void StepperController::control() {
    if(!isRunning()) return;
    static long last_compute = micros();
    if(micros() - last_compute > Settings::Stepper::STEPPER_COMPUTE_DELAY){
        m_sA.control();
        m_sB.control();
        m_sC.control();
        last_compute = micros();
        
    }

    m_sA.step();
    m_sB.step();
    m_sC.step();
}
    
// computeMoveTime() – Using full acceleration and MAX_SPEED for the longest move.
double StepperController::computeMoveTime(long maxDistance) {
    double maxAccel = Settings::Stepper::MAX_ACCEL;
    double maxSpeed = Settings::Stepper::MAX_SPEED;
    double t_accel = maxSpeed / maxAccel;
    double d_accel = 0.5 * maxAccel * t_accel * t_accel;
    
    if (maxDistance <= 2 * d_accel) {
        // Triangular profile (never reaches MAX_SPEED)
        return 2.0 * sqrt(static_cast<double>(maxDistance) / maxAccel);
    } else {
        // Trapezoidal profile.
        double t_flat = (maxDistance - 2 * d_accel) / maxSpeed;
        return 2.0 * t_accel + t_flat;
    }
}
    
// pause() – Set target velocities to zero and change state.
void StepperController::pause() {
    if (isRunning()) {
        m_sA.setTargetVelocity(0);
        m_sB.setTargetVelocity(0);
        m_sC.setTargetVelocity(0);
        Job::pause();
    }
}

// resume() – When in Paused state, simply restart the move using new start time.
void StepperController::resume() {
    if (isPaused()) {
        m_startTime = micros() * 1e-6;
        Job::resume();
    }
}

// complete() – Immediately stop and reset the trajectory data, then disable the steppers.
void StepperController::complete() {
    m_sA.setTargetVelocity(0);
    m_sB.setTargetVelocity(0);
    m_sC.setTargetVelocity(0);
    m_sA.disable();
    m_sB.disable();
    m_sC.disable();
    // Reset internal move parameters.
    m_startA = m_startB = m_startC = 0;
    targetA = targetB = targetC = 0;
    m_totalDistanceA = m_totalDistanceB = m_totalDistanceC = 0;
    m_totalTime = 0;
    m_startTime = 0;
    Job::complete();
}

// cancel() – Decelerate (using pause) then complete the move.
void StepperController::cancel() {
    Job::cancel();
    pause();
}

// reset() – If a move is running, cancel it; then reset all internal parameters.
void StepperController::reset() {
    if (isRunning()) {
        cancel();
    }
    Job::reset();
    m_startA = m_startB = m_startC = 0;
    targetA = targetB = targetC = 0;
    m_totalDistanceA = m_totalDistanceB = m_totalDistanceC = 0;
    m_totalTime = 0;
    m_startTime = 0;

    m_sA.setPosition(0);
    m_sB.setPosition(0);
    m_sC.setPosition(0);
}

// Helper: computeEffectiveAcceleration()
// For a given distance and total time, use a triangular profile if the ideal peak velocity is below MAX_SPEED;
// otherwise, compute an effective acceleration that prolongs the move (trapezoidal profile).
double StepperController::computeEffectiveAcceleration(long distance, double totalTime) {
    double maxSpeed = Settings::Stepper::MAX_SPEED;
    // If the ideal triangular peak velocity (2D/T) is lower than MAX_SPEED, use a triangular profile.
    if (2.0 * distance / totalTime <= maxSpeed) {
        return 4.0 * distance / (totalTime * totalTime);
    } else {
        // Trapezoidal: Determine the acceleration time (t1) needed to reach MAX_SPEED in this stretched move.
        double t1 = totalTime - static_cast<double>(distance) / maxSpeed;
        return maxSpeed / t1;
    }
}

// Helper: computeProfileVelocity()
// For a move of (absolute) distance D to be completed in totalTime seconds,
// compute the desired instantaneous velocity at elapsed time t.
double StepperController::computeProfileVelocity(long distance, double t, double totalTime) {
    double maxSpeed = Settings::Stepper::MAX_SPEED;
    if (2.0 * distance / totalTime <= maxSpeed) {
        // Triangular profile.
        double a_eff = 4.0 * distance / (totalTime * totalTime);
        if (t < totalTime / 2.0)
            return a_eff * t;
        else
            return a_eff * (totalTime - t);
    } else {
        // Trapezoidal profile.
        double t1 = totalTime - static_cast<double>(distance) / maxSpeed;
        double a_eff = maxSpeed / t1;
        if (t < t1)
            return a_eff * t;
        else if (t <= (totalTime - t1))
            return maxSpeed;
        else
            return a_eff * (totalTime - t);
    }
}


